# 이상한 나라의 객체 2부

### 1부 복습

1부에선 심리학 연구를 화두로 객체지향 프로그래밍이 사실상 인간의 기본적인 본능인 인지능력과 매우 깊은 연관이 있다는 걸 알 수 있었다. 객체지향 패러다임은 복잡한 소프트웨어 세계를 인간이 이해하기 쉽게 개념을 쪼개 소프트웨어의 객체를 **_책임, 역할, 협력_** 세가지로 설계 할 수 있게 무대를 제공했다.

객체의 상태는 객체의 내부에 캡슐화 되어있고, 스스로의 상태는 반드시 자신의 행동으로 변경할 수 있도록 해야한다. 만약 다른 객체가 상태를 변경하고 싶다면, 객체 간의 협력을 기반으로 상태 변경을 시도하면 된다. 앞서 말한 조건들을 모두 충족시켜줘야 비로소 소프트웨어 속 객체지향 패러다임을 토대로 컴퓨터 세계 속 자원을 다룰 수 있다.

### 식별자

1부에서도 언급이 되었듯이, 객체는 인간이 인지 능력을 통해 식별할 수 있는 모든 존재를 의미한다. 식별을 하기 위해선 특별한 식별장치가 필요하다. 소프트웨어 세계에선 해당 속성을 **식별자**라고 부른다. 모든 객체는 식별자를 가지고, 식별자를 이용해 객체를 구별할 수 있다.

반대로 객체가 아닌 단순한 값은 식별자를 지니지 않는다. 이는 값과 객체의 구분점이 될 수 있다. 흔히 값의 상태는 변하지 않기에 **불변 상태(immutable state)** 을 가진다고 말한다. 우리가 보통 숫자나 알파벳을 사용할 때 서로 다른 필기나 폰트에 따라 식별하는 방식이 다르지 않듯이 두 인스턴스가 서로 같은지 판단할 땐 반드시 상태의 불변성을 지켜줘야한다.

이처럼 상태를 이용해 두 값이 같은지 판단할 수 있는 성질을 **동등성(equality)** 이라고 한다. 값은 오직 상태만을 이용해 동등성을 판단하기 때문에 인스턴스를 구별하기 위한 별도의 식별자를 필요로 하지 않는다.

행동을 통해 상태를 수시로 변경할 수 있는 객체는 **가변 상태(mutable state)** 를 가진다고 말한다. 객체의 타입이 같더라도 서로 다르다고 식별을 할 수 있어야 한다. 실제 세계 에서도 같은 이름과 같은 특징을 가진 사람이 있다해도 다른 사람으로 인식하는 것처럼 말이다. 이를 가능케 해주는 것이 바로 **식별자**다. 식별자를 기반으로 객체가 같은지 판달 할 수 있는 성질을 **동일성(identical)** 이라고 한다.

상태를 기반으로 객체의 동일성을 판단할 수 없는 이유는, 상태는 객체의 행동에 의해 언제든 변할 수 있기 때문이다. 상태가 가변적인 객체들의 동일성을 판단하기 위해서는 반드시 상태에 의존성이 없는 독립적인 식별자를 사용해야 한다.

책에서는 아래와 같이 식별자를 정의했다:

```
식별자란 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티다. 값은 식별자를 가지지 않기 때문에 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교해야 한다. 객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있다.
```

값과 객체의 개념적 차이로 혼동을 갖을 수 있다. 참조 객체(reference object) , 또는 엔티티(entity)는 식별자를 지닌 객체를 의미한다. 값 객체(value object)는 식별자를 가지지 않는 값을 뜻한다.

객체 식별자의 개념은 상속, 캡슐화, 다형성과 달리 눈에 띄는 개념이 아니라서 간과하기가 쉽다. 하지만 객체지향 패러다임의 표현력 높이는 데 식별자 만큼 중요한 역할이 많이 없다는 것은 사실이다. 지금 까지의 묘사된 객체의 특징들을 살펴보면 다음과 같다:

- 객체 내부엔 상태가 있으며, 상태는 스스로의 행동에 의해 변경 가능하다.
- 행동이 만들어낸 결과는 상태에 의존하며 그 결과를 상태로 서술할 수 있다.
- 행동의 순서는 실행 결과에 영향을 미친다.
- 객체를 모든 시점에서 유일하게 인식할 수 있도록 식별자가 별도로 존재한다.
  또한 식별자가 동일하다면 해당 객체는 동일 인스턴스다.

### 기계로서의 객체

버트란드 마이어는 객체가 내부를 직접적으로 관찰할 수 없는 기계라고 비유를 한다. 기계의 상태를 변경하기 위해 기계 외부에 부착되어 있는 컨트롤러를 이용해 기계와의 상호작용을 할 수 있다. 그리고 행동에 의한 결과물은 디스플레이에서 확인 할 수 있다.

```
객체의 상태를 조회하는 작업을 쿼리(query)라고 하며 객체의 상태를 변경하는 작업을 명령(command)라고 부른다. 객체가 외부에 제공하는 행동의 대부분은 쿼리와 명령으로 구성된다.
```

객체를 기계로 비유하는 데에 있어선 여러가지 소프트웨어 속 객체의 특징을 잘 강조해줬다. 이를테면 내부를 직접적으로 볼 수 없다는 부분은 객체의 캡슐화를 의미한다. 기계의 상태를 바꾸고 싶다면 외부에 제공된 특정 행동을 따라야 한다는 점은 상태와 행동이 하나의 단위로 캡슐화된다는 객체의 정의를 더할 나위 없이 효과적으로 표현해냈다. 물론 실 세계 속 객체로서 비유를 했기에, 식별자라는 개념도 암묵적으로 존재한다는 사실 또한 기계로 소프트웨어 속 객체를 비유한 것이 얼마나 탁월했는지 알 수 있다.

보통 하나의 기계에는 동시에 여러 부품들이 내재되어있으며 동시 다발적으로 하나 또는 그 이상의 임무를 수행한다. 이는 객체 간 협력 관계를 빗대어 볼 수있다. 부품들 끼리 정보를 주고 받으며, 적절한 시기에 서로 필요한 동작을 수행하기 때문이다.

### 행동이 상태를 결정한다

객체지향 초기 설계 중 가장 조심해야 할 부분이 바로 상태 중심으로 객체를 바라보는 것이다. 객체의 상태는 행동에 의해 결정되어야 한다. 상태를 먼저 결정하고 행동을 추후에 결정한다면 설계에 나쁜 영향을 끼칠 수 있다.

간략하게 설명하자면, 상태를 먼저 결정하는 방식은 캡슐화를 저해할 수 있고, 객체 간의 협력을 하기 어렵게 만들어준다. 최종적으로 객체의 재사용성이 떨어지므로 객체지향 패러다임을 사용하는 메리트가 줄어든다고 할 수 있다.

객체지향 설계는 실 서비스에서 필요한 협력관계를 고민하고 협력에 내재될 행동을 정하고 그 행동을 수행할 객체를 선택하는 방식으로 수행된다. 행동이 결정되어야 어떤 상태가 필요한지 고민할 수 있기 때문에 항상 객체의 행동을 결정한 뒤 적절한 상태를 선택할 수 있도록 전체 틀을 설계해야한다.

협력 안에서 객체의 행동은 협력 속 지켜야 할 책임을 의미한다. 그렇기에 어떤 책임이 필요한지 결정하는 과정이 전체 설계를 주도해야한다. 이 개념을 책임-주도 설계(Responsibility-Driven Design, RDD)로 정의할 수 있다. 이는 협력이라는 문맥 속에서 객체의 행동을 생각하도록 도와 응집도 높고 재사용 가능한 객체를 만들 수 있게 한다.

해당 챕터에서 저자가 가장 강조하고 싶은 문장이 바로 "행동이 상태를 결정한다" 라고 한다. 책을 읽으면서 이 문장의 뜻을 이해할 수있도록 노력해보자.

### 은유와 객체

사람들은 객체지향에 매우 큰 오해를 하고 있다. "객체지향이란 현실 세계의 모방"이라는 문장으로 객체지향을 이해하려하기 때문이다. 안타깝게도 객체지향 세계는 실 세계의 단순한 모방이 아니다. 소프트웨어 상의 객체는 이상한 나라처럼 훨씬 기묘하고 상식을 빗겨나간다. 모방과 추상화라는 개념으론 현실 객체와 소프트웨어 객체 간의 관계를 정리할 수 없다. **객체지향이 현실을 오롯이 모방하기만 한다는 것은 오해일 뿐이다.**

소프트웨어 속 객체의 가장 다른 부분은 모든 객체는 능동적으로 행동한다는 것이다. 객체지향 세계의 객체는 현실 세계 속 객체보다 많은 기능을 자유자재로 추가 삭제할 수 있다. 레베카 워프스브록은 이런 특징을 객체의 의인화(anthropomophism)라고 부른다. 정적인 사물에 생명을 불어넣는 행위와 흡사하기 때문이다.

```
의인화의 관점에서 소프트웨어를 생물로 생각하자. 모든 생물처럼 소프트웨어는 태어나고, 삶을 영위하고, 그리고 죽는다. - Wirfs-Brock
```

객체지향의 궁극적인 목적은 현실과 전혀 다른 새로운 세계를 창조하는 것이다. 객체지향의 세계는 현실의 추상화가 아니다, 오히려 객체지향 속 객체는 훨씬 더 많은 특징과 능력을 보유하게된다.

전통적인 소프트웨어 설계 관점은 현실 세계의 객체를 자세히 관찰하고 그 것을 소프트웨어 세계 속으로 접목하는 것에 초점을 뒀다. 하지만 이런 방식은 실질적인 도움이 되지 않을 뿐더러 객체지향에 대한 오해만 더 깊게 만든다.

객체지향의 세계와 현실 세계 사이에 관계를 설명할 수 있는 단어로 은유(metaphor)가 있다. 은유란 적용되지 않는 한 가지 개념을 이용해 다른 개념을 서술하는 방법이다. 현실 정보의 일부를 컴퓨터 세상 속 객체의 속성으로 전달해주기에 객체지향은 현실 세계의 은유하고 볼 수 있다. 은유 관계에 있는 실제 객체의 이름을 소프트웨어 객체의 이름으로 사용하면 표현적 차이를 줄여 구조를 쉽게 예측할 수 있게하고 가독성을 올려줄 수 있다. 이런 부분 때문에 객체지향 설계 참조서에선 항상 현실 세계인 도메인에서 사용되는 이름을 객체에게 부여하라고 가이드한다.

### 이상한 나라를 창조하라

객체지향 설계자의 목적은 현실을 모방하는 것이 아닌 이상한 나라를 창조하는 것이다. 현실을 무조건 닮아야 한다는 건 오히려 제약이 될 수 있다. 현실 세계의 특정 존재를 은유할 수 있다면 소프트웨어 객체를 설계할 때 참조하면 된다. 만약 그렇지 않는다 해도 걱정하지 말자, 객체지향 속 세계는 현실 세계보다 훨씬 강력하고 변화무쌍하기에, 자유롭게 설계자가 원하는 새로운 세계를 창조해나가면 된다.
