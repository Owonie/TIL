### 옵저버 패턴

주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때 마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴이다.

헷갈리기 쉬운 점은, 옵저버 주체는 객체를 관찰하고 있는 역할이지, 객체 그 자체가 아니다. 물논 주체와 관찰자를 구분 짓지않고 하나의 객체로 구축하기도 한다.

옵저버 패턴은 주로 이벤트 기반 시스템에 사용하며 MVC 패턴에도 사용된다. 자바스크립트에선 프록시 객체로 옵저버 패턴을 구현할 수 있다.

```ts
const handler = {
  get: function (target, name) {
    return name === 'name' ? `${target.a} ${target.b}` : target[name];
  },
};
const p = new Proxy({ a: 'KUNDOL', b: 'IS AUMUMU ZANGIN' }, handler);
console.log(p.name); // KUNDOL IS AUMUMU ZANGIN
```

프록시 객체는 target과 handler 두 개의 매개변수를 전달 받는다. 이는 이벤트 핸들러를 처리하는 방식과 똑같다. MVVM 패턴이 사실상 이벤트 버스 기반으로 동작하기에, 대표적인 프록시-옵저버 패턴이라고 할 수 있다.

### 프록시 패턴

프록시 패턴은 대상 객체에 접근하기 전에 해당 접근을 가로채 추가적인 동작을 수행할 수 있도록 하는 디자인 패턴이다. 제일 대표적인 예로 프록시 서버가 있다.

프록시 서버는 서버와 클라이언트 사이에 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있는 시스템 또는 응용 프로그램을 가리킨다. VPN 또는 캐싱서버들이 이런 역할을 수행한다 볼 수 있다.

엔직스 서버로 Node.js의 실제 서버 포트를 감출 수 있으며, 정적 자원을 압축하거나 메인 서버 앞단에서의 로깅을 할 수 있다. 버퍼 오버플로우를 방지할 수 있다.

프록시 서버로서 유명한 CloudFlare도 있다. 실제 서버와 클라이언트 사이에서 DDOS 공격을 방어할 수 있으며, 인증서를 사용하지 않아도 손 쉽게 HTTPS를 구축할 수 있다.

프론트엔드 서버에서 CORS를 방지하기 위해 따로 프록시 설정을 해주는 것 또한 프록시 서버와 비슷한 원리다.

### 이터레이터 패턴

자료구조와 상관없이 순회할 수 있는 인터페이스 디자인 패턴이다.

### 노출 모듈 패턴

```ts
const pukuba = (() => {
  const a = 1;
  const b = () => 2;
  const public = {
    c: 2,
    d: () => 3,
  };
  return public;
})();
console.log(pukuba);
console.log(pukuba.a);
// { c: 2, d: [Function: d] }
// undefined
```

즉시 실행 함수를 통해 접근 제어자를 만드는 패턴을 의미한다. public만 return 되기에 public 안에 감싸져있는 데이터만 외부에서 접근이 가능하다. 이는 클로저를 활용한 패턴이다.

### MVC 패턴

Model, View, Controller로 이루어진 디자인 패턴이다. 애플리케이션의 구성요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있다. 스프링 프레임워크에서 MVC패턴을 자주 활용한다.

### MVP 패턴

MVC의 C가 프레젠터로 교체된 패턴이다. 뷰와 프레젠트가 일대일 관계이기 때문에 MVC패턴보다 더 강한 결합을 지닌 디자인 패턴이라고 볼 수 있다.

### MVVM 패턴

MVC의 C가 view model로 변경된 패턴이다. 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉽다는 장점이 있다. Vue.js가 대표적인 MVVM 패턴을 가진 프레임워크다.
