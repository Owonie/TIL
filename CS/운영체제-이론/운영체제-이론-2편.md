# 운영체제 이론 2편

### 컴퓨터는 3층 구조를 갖고 있다.

하드웨어 (물리적) 소프트웨어 (로지컬/버추얼)
OS는 다른말로 플랫폼이라고 한다. 운영체제는 어플리케이션을 서포트하고, 하드웨어를 관리하고 제어한다.
한 컴퓨터에서 여러개의 프로세스를 실행하려면 운영체제가 잘 케어해줘야한다.
운영체제를 잘 이해하려면 하드웨어를 기본적으로 이해해야한다. Interrupt는 하드웨어끼리 I/O가 생길 때 마다 발생하는 이벤트인데, 이런 흐름들을 컨트롤하는 것이 바로 운영체제다.

print(‘hello world’) 라는 명령어를 실행하면, 실행 프로세스에서 API요청을 호출하여 커널로 명령이 특정 인터페이스를 거쳐 진입하게 된다. 커널에 진입한 뒤 명령어는 새로운 형식으로 전환이 되는데 이 전환된 결과물을 System Call이라고 부른다. System Call은 Device Driver를 통해 특정 하드웨어를 구동할 수 있다. Device Driver내부에서 Interrupt를 요청한다(IRQ는 고유번호를 갖는다.).

```
print(‘hello world’) 실행
-> 프로세스가 API 요청
-> 커널로 진입하며 명령어는 System Call로 전환
-> System Call에서 Device Driver로 명령
-> Deviece Driver 내부에 IRQ 발생
-> 스케줄링에 따라 하드웨어에 접근(모니터)
-> 실행이 끝났다고 다시 위로 함수 값 반환
```

### 인터럽트는 매우 중요하다

인터럽트는 현재 진행 중이던 작업을 중단시키는 개념을 이해할 수 있다. 소프트웨어 관점에선 시스템이 원활하게 동작하기 위해 인터럽트에 우선순위를 설정해야 한다. 물론 스프트웨어의 기능적인 관점 외에도 인터럽트라는 개념을 사용할 수 있다.
인터럽트의 종류는 주로 외부 인터럽트, 내부 인터럽트, 소프트웨어 인터럽트로 분류할 수 있다.

외부 인터럽트:

> 보통 물리적으로 전원이나 CPU에 기능적 문제가 생겨 이상을 일으키는 인터럽트가 있고, 외부 신호로 인한 인터럽트, 그리고 I/O 인터럽트가 있다.

RAM <-> CPU로 동작하는게 기본이었지만, 요즘은 메모리를 관리하는 입출력 관리자를 통해 간접적으로 I/O인터럽트를 관리한다.

내부 인터럽트:

> 잘못된 명령이나 데이터를 이용할 때 Trap이라는 인터럽트가 있다. 프로그램 검사 인터럽트로서 Division by zero, overflow/underflow/ Exception 등이 있다.

인터럽트의 동작순서는 아래와 같다:

```
인터럽트 요청
-> 프로그램 중단 (현재 실행중인 Micro operation까지 수행)
-> 현재의 프로그램 보존(Process Control Block),PC(program counter)등
-> ISR 실행
-> 상태복구
-> 중단된 프로그램 실행 재개.
```

인터럽트의 우선순위:

> 전원 이상 > 기계 착오 > 외부 신호 > 입출력(I/O) > 명령어 잘못 > 프로그램 검사 > SVC

**DirectX**에 대한 얘기가 잠깐 나왔는데, 예전엔 유저와 커널사이에 GDI엔진이라는 그래픽 처리 요소가 있었는데, 유저단에서 게임을 실행하면 GDI API를 호출해서 Device Driver와 상호작용하기위해 너무 많은 단계를 거쳐야했다. 성능저하를 피하기위해 만든 것이 바로 DirectX인데, 그래픽 엔진 부분에 있어서 I/O 성능을 극단적으로 끌어올릴 수 있었다.

### DMA(direct memory access)

고성능과 밀접한 연관이 있는 개념이다. 메모리는 CPU의 cache메모리와 RAM의 메모리가 있는데, DMA에는 RAM의 메모리만 생각하면 된다. I/O 관리자는 보통 메인보드에 위치하는데 CPU의 작업실행을 보조해준다.
네트워크 인터페이스 카드에서 자주 나오는 내용이다. DMA는 복잡한 메모리 복사 과정을 생략하고 직접적으로 메모리를 관리할 수 있도록 도와준다. 발신의 과정을 기술해봤다:

```
발신 : 네트워크 데이터 -> Socket send (I/O Buffer) -> Segment -> NIC -> 네트워크(수신쪽)
```

수신의 과정은 아래와 같다.

```
수신 : Process에서 데이터를 Receive를 하기위해 RAM메모리를 확보하고 대기를 탄다
-> NIC가 DMA를 지원한다면 OS가 Lock을 걸어서 NIC에서 받은 메모리를 프로세스가
확보해둔 메모리로 바로 보내준다.
```

**VM**(가상환경)은 이를 더 큰 범주로 적용해서 속도를 극대화 할 수 있다. 두 유저간의 네트워크 교류가 사실상 같은 VM에서 동작하기 때문에, 굳이 클래식한 방식 처럼 각종 Interrupt를 거치지 않아도 된다.

### CPU는 연산할 내용을 예측하여 실행한다.

연상장치에서 가장 중요한건 속도다, 물리적인 한계를 돌파하기 위해 코어의 수를 올리고 있다. 코어와 램의 속도차이는 대략 50배 정도 되는데, 이를 해결하려고 도입한게 중간 역할을 해주는 케시 메모리다.

케시메모리에는 명령과 데이터가 들어가있다. 필요한 데이터 공간을 미리 예측해서 선언하고, 추후에 사용할 수 있도록 한다.
