# 운영체제 이론 7편

### 가상메모리

가상메모리체계는 시스템 프로그래밍을 다루는 내용에서 멀티 스레딩 / 프로세스 와 함께 매우 중요한 내용이라고 한다. 메모리는 1차 메모리(RAM)와 2차 메모리(HDD/SDD)가 있는데, 메모리의 크기가 서로 다르기 떄문에 소프트웨어가 메모리의 규격에 따라 버전별로 설정해줘야하는 문제가 있었다. 이런 장치에(메모리) 대한 의존성을 가상메모리가 없에 줄 뿐 아니라 관리적 의미에서 추상성을 제공하여 접근제어(보안)을 가능케 한다.
가상메모리는 32/64bit에 따라 상수단위가 결정된다. 강의에선 32비트를 기준으로 가상메모리에 대한 개념을 설명한다. 32비트를 기준으로 했을 때 VMS라는 가상메모리 공간이 있다면, 이를 반으로 공간을 분할하여 User영역과 Kernel영역으로 나눈다, 이때 User의 0번대 주소 부근은 OS가 차지하도록 설계되어있다.

가상시스템에서 메모리 메니저는 RAM+Swap영역을 관리한다. 프로세스가 사용하는 가상주소공간을 실제 물리메모리로 전환하는데, 이를 동적 주소 변환이라고 한다. 여기서 동적은 Runtime내에서 실행된다는 뜻이다. 가변분할 방식으로 프로세스의 공간을 할당해준다 해도, VMS와 같은 방식으로 주소공간을 분배하도록 한다.
물리메모리에는 절대주소가 부여되어있는데, 가상메모리 상의 주소가 같다고 해도 물리 메모리 상에서도 같은 주소를 가르키는건 절대 아니다. 여기서 매핑 테이블이라는 중요한 개념이 나오는데, 이는 프로세스(VMS)가 실제 물리적인 메모리 주소를(세그먼트)에 매핑해주는 중요한 기능을 한다. 매핑 테이블은 보통 배열일 가능성이 매우 높다. 운영체제가 매핑 테이블을 관리하면 좋은 점이 있는데, 프로세스가 잘 작동하다가 오작동 때문에 갑작스럽게 terminate가 된 경우 운영체제의 메모리 매니저가 신속히 물리적 공간을 회수해서 자원적 낭비를 없애 줄 수 있다. 메모리의 회수는 RAM의 성능을 온전히 사용할 수 있도록 보장해준다, 그리고 그 것을 매니저 메모리가 가능하도록 만들어준다.

### 가상메모리 페이징 기법의 구현

가상메모리의 페이징 기법은 매우 중요한 내용이다. C언어의 포인터라는 개념을 잘 이해하려면 기본적으로 컴퓨터의 구조에 대한 이해도와 VMS(가상메모리공간)에 대한 개념을 어느정도 숙지해야한다. VMS(32bit기준)은 4GB의 용량이 있는 배열이다. 즉 해당 배열 내부에 Stack / Heap과 같은 요소들이 선형적으로 배치되어있다. Page는 윈도우 체계를 기준으로 4kb정도 차지를 한다.
![](https://velog.velcdn.com/images/dev_dowon/post/75b30b4f-0b9a-4072-b60d-8e0a17d10b4f/image.png)

여기서 프레임과 페이지는 모두 메모리를 일정한 크기의 공간으로 나누어 관리하는 단위이다. 프레임은 물리 메모리를 일정한 크기로 나눈 블록이며, 페이지는 가상 메모리를 일정한 크기로 나눈블록이다. 보통 프레임과 페이지의 크기를 같은 사이즈로 맞추며, 페이지가 하나의 프레임을 할당 받으면 물리 메모리에 위치할 수 있게 된다. 페이징 기법은 사실상 주소공간을 페이지 단위로 나누고 실제 메모리 공간은 페이지 크기와 같은 프레임으로 나누어 사용된다.
![](https://velog.velcdn.com/images/dev_dowon/post/d133d0fc-dffb-4ba2-a5c6-83008f4b4c79/image.png)

가상주소 VA = <P,D> 라는 간단한 관계가 있는데, 여기서 P는 페이지 호수, D는 distance(offset)을 상징한다. 페이지 테이블은 상대적인 프로세스의 주소를 물리적인 절대 주소에 매칭할 수 있도록 도와준다.
운영체제의 스와퍼는 물리 메모리에 동작하고 있는 모든 프로세스를 로드하지 않는다. 그리고 프로세스의 모든 페이지를 물리 메모리에 로드하지 않기 떄문에 프로그램의 페이지가 물리 메모리에 부재하는 경우 페이지 폴트 현상이 일어날 수 있다.
운영체제가 페이지 테이블을 이용해 요구 페이징 수행을 하는 과정은 아래와 같다:

```
1. CPU는 물리 메모리을 확인하여 페이지가 없으면 trap을 발생하여 운영체제에 알린다.
2. 운영체제는 CPU의 동작을 잠시 멈춘다.
3. 운영체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인하고, 없으면 프로세스를 중단한다.
4. 페이지 폴트이면, 현재 물리 메모리에 비어있는 프레임(Free Frame)이 있는지 찾는다.
5. 비어있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화 한다.
6. 중단되었던 CPU를 다시 시작한다.
```

물리 메모리에 비어있는 프레임이 없으면 희생 프레임을 골라서 이를 가상 메모리에 저장 후 필요한 페이지를 물리 메모리에 불러온다, 이 때 페이지 교체 알고리즘이 사용하게 된다.
