# 네트워크 기초 이론 10편

### MTU와 Packet 단편화

IP 헤더의 구조는 아래의 그림과 같다.
![](https://velog.velcdn.com/images/dev_dowon/post/02268bb2-ad9a-47e5-9007-70c25f61cba3/image.png)

단편화의 내용은 Identification + IP Flags + Fragment Offset에 들어가있다.
MTU는 1500byte가 제공된다. MSS: MTU - 20(IP 헤더) - 20(TCP 헤더) ~= 1460bytes
단편화가 발생하는 환경을 아래와같이 시나리오 가정을 해본다.
![](https://velog.velcdn.com/images/dev_dowon/post/cd85505c-f09c-4516-b5b9-56e2e882a50c/image.png)

그림을 보면 라우터 2번에 MTU가 1400인걸 알 수 있다. PC1번과 서버는 MTU가 1500인데 중간에 끼어있는 라우터의 MTU가 1400밖에 안된다면 라우터 1번과 2번 사이에서 단편화가 발생한다. 1500의 MTU를 한번에 다 담지 못하기에, 패킷을 일정 부분을 잘라서 두개의 패킷을 만들어준다. 두개의 패킷은 IP헤더에 있는 Identification값이 같다. 여기서 Offset값이 다를 수는 있다. 나중에 Offset값을 참조해서 쪼개진 패킷을 다시 조합할 수도 있다.
분할된 패킷을 어디선가 재조립을 해야되는데, 이는 선택에 따라 다를 수 있다. 기본적으로 단편화가 된 데이터를 수신한 쪽에서 재조합을 하게 되어있다, 위의 예제에서선 서버가 된다. 하지만 과도한 단편화는 서버에 과부하를 줄 수 있기에 좋은 현상은 아니다.
요즘은 사실상 기술의 발전에 의해 단편화 현상이 많이 줄어들었다. 그래서 가끔 일어나는 단편화는 VPN(IPSec) 떄문에 발생한다고 본다.
단편화가 안나게끔 MTU를 조절해서 패킷을 보내면 단편화를 피할 수도 있다고 한다. bps /pps라는 개념이 있다. bps는 데이터의 량에 대해서 설명하는 단위고, PPS는 Packet의 개수, 즉 단편화를 줄여야 PPS가 떨어지고, 데이터 처리 성능이 올라간다. 단편화를 피하기 위해 패킷을 보내는 PC단에서 패킷의 MTU를 낮추는 방법을 하향평준화라 부른다.

### packet / segment / header/ payload

Packet는 데이터 덩어리다. 패킷은 두 부분으로 나뉘는데, 각각 header와 payload다. 여기서 header는 IP header다. Payload 부분을 보게되면, 내부에 TCP 헤더가 있고 Data가 있다.
![](https://velog.velcdn.com/images/dev_dowon/post/1b0c66b6-fef7-45ee-bebf-fa1ec77baf9a/image.png)

IP Payload 내부에 TCP와 Data가 있지만 보통 패킷의 헤더라 함은 IP 헤더 + TCP 헤더를 뜻한다. 그럼 Data는 1460을 가져가고 IP / TCP 헤더에서 각각 20씩 가져간다. Data 부분을 Segment라고 본다. IP 패킷을 뜯어보면 안에 TCP헤더를 포함한 데이터가 있다.
프로세스에서 RWX를 특정 형식(프로토콜)에 따라 동작을 하는데, 인터넷 통신을 하며 데이터 송수신을 할 때 소켓은 파일형식 (Stream)이다. Stream을 패킷의 크기(MTU)에 맞게 잘르고 4계층으로 내려가면 TCP계층에서 TCP 헤더를 붙여 TCP헤더 + Data가 된다. 이를 Segment라고 부르고 그 밑으로 IP 계층으로 내려가면 IP헤더를 붙여 IP 패킷이 된다. NIC 계층으로 내려가면, Ethenet 헤더를 장착시키고 Frame 단위로 재구성 된다. L2관점에서 봤을 때 Payload는 Frame에서 Ethenet헤더 부분을 제외한 내용이다. Payload는 관점에 따라 상대적으로 바뀌는 개념이다.
TCP가 아니라 UDP라면, 헤더 부분이 Outer부분에 IP/TCP가 아닌 IP/UDP가 있고, UDP일 떈 Payload대신 Datagram이라고 부르기도 한다.

### TCP 장애유형 5가지

TCP라는 프로토콜은 생각보다 복잡하다. 장애대응의 대원칙은 무조건 장애의 확인 순서는 아래에서 위로다. 인터넷이 안된다면 무조건 물리적인 연결부터 확인하는게 원칙이라는 뜻이다.
Ethenet 수준의 Loss
엔드포인트 끝단에서 네트워크 구간 전체에서 어떤 일이 일어나는지 모르기에 loss 가 일어날 수 있는 이유가 여러가지 있다.
TCP 수준에서 DupACK

TCP 수준에서 Retransmission
위의 두 장애 유형은 보내는 쪽에서 Segment하나를 보내고 wait 상태가 되는데, 이때 받는 속도와 보내는 속도가 안맞을 때 발생한다. 이 두가지 유형은 네트워크 지연도 의심해야하고, 커널측에서 문제가 생길 수도 있다. 송수신 쪽의 세팅이(타이머) 안맞아서 그런 경우도 있다.
2,3 문제는 혼잡상태라고 본다. 이를 해결하기 위해 타이머를 조절하여 송수신 속도를 양측 다 떨어뜨린다.
Zero Window
수신측 버퍼가 꽉차는 현상이기에, 주로 어플리케이션을 확인해봐야한다. 방화벽 등 문제일 수도 있다.
소켓 통신 Reset
소켓이 엔드포인트 프로세스에서 비정상상태로 날라갔을 때 Reset을 비정상적으로 보내는 현상이다. 해킹시도가 있거나 시퀀스가 안맞을 때도 reset이 된다고 한다.
MSA(multi segment analysis): 구간마다 선을 연결(out ot path)하여 데이터가 사라지는지 체크하여 장애대응을 도와주는 도구.

### 서브넷팅

서브넷을 왜 사용하는지에 대해 알아본다. 192.168.0.10(Cclass)이라는 주소가 있다면, 앞의 세 블록은 Network ID가 되고, 뒤의 10 부분이 Host 번호가 된다. 2진수 기준 0으로 꽉찬 수 또는 1로 꽉찬수는 각각 사용되지 않는 값 또는 Broadcast로서 동작하기에, 하나의 블록에 254개의 주소가 존재할 수 있다.
리소스 낭비를 막기위해 Network ID 부분을 오른쪽으로 확장시킨다. 한칸만 오른쪽으로 확장해도 254개 주소에서 126개 주소로 경우의 수가 줄어든다. 하지만 표기법은 바꾸지 않는다. 그리고 broadcast address는 127(1로 가득참)이 된다. host 할당 가능범위는 항상 0으로 가득찬 번호~ 1로 가득찬 번호 사이다.
서브넷을 나눌수록 두개의 주소가 낭비된다. 0으로 가득찬 것과 1로 가득찬 주소는 항상 뺴야하기에, 주소가 2개가 준다. 그래서 쪼개기 전보다 더 많은 자원을 아낄 수 있기에 적절한 서브넷 쪼개기는 필요하다.

LAN공간에서 네트워크 분할을 해준다. 한 네트워크에서 Broadcast가 많이 일어날 수록 효율이 떨어진다(ARP이슈). 그래서 네트워크를 분할해준다. ISP입장에선 앞서 말했듯이 네트워크가 낭비되지 않도록 적절한 공간을 할당해준다.
네트워크가 왜 두개로 더 쪼갤 수 있냐면, 네트워크 아이디를 오른쪽으로 한칸 확장하게되면 한 자리수를 더 사용할 수 있기에 경우의 가지 수가 2배가 된다. 그렇기에 네트워크 분할을 할때마다 두개의 네트워크로 쪼개진다.
